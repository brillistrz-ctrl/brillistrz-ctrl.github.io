// doordash_pricing_exploit.js
// Ethical PoC for HackerOne - DoorDash Program
(function () {
    'use strict';

    console.log("[üîç] DoorDash /pricing Security Probe - High-Impact Vector Search");

    // === 1. Check for URL-based injection points ===
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.size > 0) {
        console.warn("[üí°] URL parameters detected:", Array.from(urlParams.keys()));
    } else {
        console.log("[‚ÑπÔ∏è] No URL parameters found.");
    }

    // === 2. Search for client-side redirects (Open Redirect candidate) ===
    const redirectKeys = ['redirect', 'continue', 'next', 'url', 'goto', 'return'];
    let redirectParam = null;
    for (const key of redirectKeys) {
        if (urlParams.has(key)) {
            redirectParam = key;
            break;
        }
    }

    if (redirectParam) {
        const target = urlParams.get(redirectParam);
        console.warn(`[üö® High-Impact Candidate] Open Redirect via ?${redirectParam}=${target}`);
        console.log("[üí° Impact]: Can be chained with phishing to steal sessions.");
    }

    // === 3. Monitor all outgoing API requests for SSRF/XSS vectors ===
    const originalFetch = window.fetch;
    window.fetch = async (...args) => {
        const [url, config = {}] = args;

        // Log all POST requests that might accept user-controlled URLs
        if (config.method === 'POST') {
            let bodyStr = '';
            if (typeof config.body === 'string') {
                bodyStr = config.body;
            } else if (config.body instanceof FormData) {
                bodyStr = '[FormData]';
            }

            // Check for SSRF-prone parameters
            const ssrfKeywords = ['url', 'image', 'webhook', 'callback', 'preview', 'src'];
            if (ssrfKeywords.some(kw => url.toLowerCase().includes(kw) || bodyStr.toLowerCase().includes(kw))) {
                console.warn("[üö® SSRF CANDIDATE] POST request with URL-like parameter:", url);
                console.log("[‚ÑπÔ∏è Body preview]:", bodyStr.substring(0, 200));
            }

            // Check for XSS-prone endpoints
            if (url.includes('/api/') && bodyStr.includes('<') && bodyStr.includes('script')) {
                console.warn("[üö® XSS CANDIDATE] Script-like payload in POST body to:", url);
            }
        }

        return originalFetch.apply(this, args);
    };

    // === 4. Scan the DOM for client-side rendering sinks (DOM-based XSS) ===
    const sinks = [
        'innerHTML',
        'outerHTML',
        'document.write',
        'location.hash',
        'location.search'
    ];

    // Simple check: if the page uses hash or search in rendering
    if (window.location.hash || window.location.search) {
        console.log("[üîç] Page uses dynamic URL fragments. Testing DOM XSS...");
        // Note: Actual exploitation would require manual testing
    }

    // === 5. Final summary ===
    console.log("[‚úÖ] Probe complete. Review console for High-impact candidates.");
    console.log("[‚ÑπÔ∏è] No external data exfiltrated. All evidence is local.");

    // === 6. Optional: Inject a safe, visible marker for UI Redressing PoC ===
    // (Only if you want to demonstrate phishing potential)
    /*
    const marker = document.createElement('div');
    marker.innerHTML = `<div style="
        position:fixed;top:10px;right:10px;background:#fff8e1;border:1px solid #ff9800;
        padding:8px;font-size:12px;z-index:999999;">‚ö†Ô∏è Security Test Marker</div>`;
    document.body.appendChild(marker);
    */
})();
